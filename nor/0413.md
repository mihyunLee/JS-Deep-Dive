## 🗝️ 오늘의 키워드

- this
- Set
- JSON

<br>

## ✏️ 밑줄친 부분

> <i> 🏷️22장. this </i>

- 생성자 함수를 정의하는 시점에는 아직 인스턴스를 생성하기 이전이므로 생성자 함수가 생성할 인스턴스를 가리키는 식별자를 알 수 없다. 따라서 **자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 특수한 식별자가 필요**하다. 이를 위해 자바스크립트는 this라는 특수한 식별자를 제공한다. (p343)

- **this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수다**. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다. (p343)

- this가 가리키는 값, 즉 **this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.** (p343)

- 일반 함수 - 전역 객체(window) / 메서드 - 호출한 객체 / 생성자 함수 - 생성할 인스턴스 (p346)

- 콜백 함수 내부의 this - 전역 객체가 바인딩된다. 콜백 함수 또한 일반 함수로 호출되었기 때문(p348)

- 화살표 함수 내부의 this - 상위 스코프의 this (p350)

- 객체 내의 메서드 프로퍼티가 가리키는 함수 객체는 객체에 포함되어 있는것이 아니라 독립적으로 존재하는 별도의 객체이므로 다른 객체의 메서드가 될 수도 있고 일반 변수에 할당하여 일반 함수로 호출될 수도 있다. 따라서 **메서드 내부의 this는 프로퍼티로 메서드를 가리키고 있는 객체와는 관계가 없고 메서드를 호출한 객체에 바인딩된다.**(p351)

- apply, call 메서드의 본질적인 기능은 함수를 호출하는 것이다. 두 메서드는 호출할 함수에 인수를 전달하는 방식만 다를 뿐 동일하게 동작한다. (p355)

- apply 메서드는 호출할 함수의 인수를 배열로 묶어 전달하고 (`.apply(thisArg, [1, 2, 3])`), call 메서드는 쉼표로 구분한 리스트 형식(`.call(thisArg, 1, 2, 3)`) 으로 전달한다. (p356)

<br>

> <i> 🏷️37장. Set과 Map </i>

### Set

- Set 객체는 중복되지 않는 유일한 값들의 집합이다. Set 객체는 배열과 유사하지만 중복이 되지 않고, 요소 순서에 의미가 없으며, 인덱스로 요소에 접근할 수 없다는 차이가 있다. (p643)

- Set 객체의 특성은 수학적 집합의 특성과 일치하여 수학적 집합을 구현하기 위한 자료구조다. (p643)

- Set 객체도 Map 객체처럼 NaN과 NaN을 같다고 평가하여 중복 추가를 허용하지 않는다. (p645)

- Set 객체에서 forEach 메서드의 첫 번째 인수와 두 번째 인수는 현재 순회 중인 요소값을 나타낸다. 배열의 경우 두 번쨰 인수에 인덱스를 전달받지만, Set 객체는 순서에 의미가 없기 때문에 두 번째 인수는 인터페이스를 통일하기 위해서만 존재한다. (p648)

<br>

> <i> 🏷️43장. Ajax </i>

### JSON

- **JSON은 클라이언트와 서버 간의 HTTP 통신을 위한 텍스트 데이터 포맷이다.** 자바스크립트에 종속되지 않는 언어 독립형 데이터 포맷이다. (p818)

- `JSON.stringify` 객체 or 배열 → JSON 포맷의 문자열 (직렬화) (p819)

- `JSON.parse` JSON 포맷의 문자열 → 객체 (역직렬화) (p821)

- 배열이 JSON 포맷의 문자열로 변환되어 있는 경우 JSON.parse는 문자열을 배열 객체로 변환하고, 배열의 요소가 객체인 경우 배열의 요소까지 객체로 변환한다. (p821)
