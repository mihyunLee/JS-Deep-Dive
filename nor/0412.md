## 🗝️ 오늘의 키워드

- 스코프
- 스코프 체인
- 생명주기
- 생성자

<br>

## ✏️ 밑줄친 부분

> <i> 🏷️13장. 스코프 </i>

- **모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다.** 이를 스코프라 한다. (p190)

- **스코프(scope)는 식별자가 유효한 범위를 말한다.** (p190)

- 자바스크립트 엔진은 이름이 같은 두 개의 변수 중에서 어떤 변수를 참조해야 할 것인지를 결정하고, 이를 식별자 결정이라 한다. 자바스크립트 엔진은 스코프를 통해 어떤 변수를 참조해야할 것인지 결정한다. (p191)

- 컴퓨터에서 파일 구조처럼 프로그래밍 언어에서는 스코프를 통해 식별자의 충돌을 방지하여 같은 이름의 식별자를 사용할 수 있게 한다. (p192)

- 지역은 **함수 몸체 내부**를 말한다. 지역에 변수를 선언하면 지역 스코프를 갖는 지역 변수가 된다. (p194)

- **지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다.** (p194)

- 함수는 중첩될 수 있으므로 함수의 지역 스코프도 중첩될 수 있다. 이는 **스코프가 함수의 중첩에 의해 계층적 구조를 갖는다**는 것을 의미한다. (p194)

- 함수의 중첩에 의해 스코프가 계층적으로 연결된 것을 **스코프 체인**이라 한다. (p195)

- **변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다**. (p195)

- 지역이 함수 몸체 내부를 말한다는 것은 코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다는 의미이다. (p197)

- 함수 몸체만이 아니라 모든 코드 블록이 지역 스코프를 만드는 특성을 **블록 레벨 스코프**라 한다. 하지만 var 키워드로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 이러한 특성을 **함수 레벨 스코프**라 한다. (p197)

- 함수의 **상위 스코프를 결정할 때 함수를 어디서 호출**했는지가 기준이 된다면 **동적 스코프** 방식이라 하고, **정의한 위치**가 기준이 된다면 **렉시컬 스코프** 또는 **정적 스코프** 방식이라 한다. (p199)

- **자바스크립트는 렉시컬 스코프를 따르므로 어디서 정의했는지에 따라 상위 스코프를 결정한다.** (p199)

- 함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않기 때문에 **함수의 상위 스코프는 언제나 자신이 정의된 스코프다.** (p199)

```js
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // 1
bar(); // 1
```

<br>

> <i> 🏷️14장. 전역 변수의 문제점 </i>

- 변수는 선언에 의해 생성되고 할당을 통해 값을 갖으며 언젠가 소멸하는 생명 주기가 있다. (p200)

- **전역 변수의 생명 주기는 애플리케이션의 생명 주기와 같다.** 하지만 함수 내부에서 선언된 **지역 변수는 함수가 호출되면 생성되고 함수가 종료하면 소멸한다.** (p200)

- 변수의 생명주기는 메모리 공간이 확보된 시점부터 메모리 공간이 해제되어 가용 메모리 풀에 반환되는 시점까지다.
  변수는 자신이 등록된 스코프가 소멸(메모리 해제)될 때까지 유효하다. 할당된 메모리 공간은 더 이상 누구도 참조하지 않을 때 가비지 콜렉터에 의해 해제되어 가용 메모리 풀에 반환된다. 즉, **누군가가 메모리 공간을 참조하고 있으면 해제되지 않고 확보된 상태로 남아있게 되고, 이는 스코프도 마찬가지다.**
  누군가 스코프를 참조하고 있으면 스코프는 소멸하지 않고 생존하게 된다. (p201)

- 전역 변수의 문제점(p203~p204)
  - **암묵적 결합 허용** - 모든 코드가 전역 변수를 참조하고 변경할 수 있다. 변수의 유효 범위가 크면 클수록 코드의 가독성은 나빠지고 의도치 않게 상태가 변경될 수 있는 위험성이 높아진다.
  - **긴 생명 주기** - 전역 변수는 생명주기가 길기 때문에 변수 이름이 중복될 가능성이 있고, 메모리 리소스를 오랜 기간 소비한다.
  - **스코프 체인 상에서 종점에 존재** - 전역 변수는 스코프 체인 상에서 종점에 존재하므로 변수 검색 시 가장 마지막에 검색되어 검색 속도가 가장 느리다.
  - **네임스페이스 오염** - 자바스크립트는 파일이 분리되어 있어도 하나의 전역 스코프를 공유하기 때문에 동일한 이름으로 명명된 전역 변수나 전역 함수가 같은 스코프가 존재하여 예상치 못한 결과를 가져올 수 있다.
- 전역에 네임스페이스 역할을 담당할 객체를 생성해서 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가할 수 있다. (p206)

```js
var MYAPP = {}; // 전역 네임스페이스 객체

MYAPP.person = {
  name: "Lee",
  address: "Seoul",
};

console.log(MYAPP.person.name); // Lee
```

- 단, 네임스페이스는 충돌을 방지하는 효과는 있으나 객체 자체가 전역 변수에 할당되므로 그다지 유용하지는 않다. (p206)

- ES6 모듈은 파일 자체의 독자적은 모듈 스코프를 제공한다. script 태그에 `type="module"` 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작한다.
  모듈의 파일 확장자는 `.mjs` 를 권장한다. (p207)

- 브라우저의 ES6 모듈 기능을 사용하더라도 트랜스파일링이나 번들링이 필요하기 때문에 아직까지는 Webpack 등의 모듈 번들러를 사용하는 것이 일반적이다. (p207)

<br>

> <i> 🏷️17장. 생성자 함수 </i>

- 생성자 함수란 **new 연산자**와 함꼐 호출하여 객체(인스턴스)를 생성하는 함수를 말한다. 생성자 함수에 의해 생성된 객체를 인스턴스라 한다. (p235)

- 객체 리터럴에 의한 객체 생성 방식은 직관적이고 간편하지만 단 하나의 객체만 생성할 수 있다. (p236)

- 생성자 함수에 의한 객체 생성 방식은 **객체를 생성하기 위한 템플릿처럼 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다.** (p237)

- 생성자 함수는 자바와 같은 클래스 기반 객체지향 언어의 생성자와는 다르게 **일반 함수와 동일한 방법으로 생성자 함수를 정의하고 new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다.** (p238)

- 자바스크립트 엔진은 암묵적으로 인스턴스를 생성하고 초기화 한 후 암묵적으로 인스턴스를 반환한다. (p239)

- 암묵적으로 생성된 빈 객체인 인스턴스는 this에 바인딩 된다. 생성자 함수 내부의 this가 생성자 함수가 생성할 인스턴스를 가리키는 이유가 바로 이것이다. (p239)

```js
function Circle(radius){
	// 암묵적으로 인스턴스가 생성되고 this에 바인딩 된다.
	console.log(this); // Circle {}

	...
}
```

- this에 바인딩이 되면, 바인딩되어 있는 인스턴스에 프로퍼티나 메서드를 추가하고 생성자 함수가 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화하거나 고정값을 할당한다. ⇒ **인스턴스 초기화** (p239)

- 생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다. 만약 this가 아닌 다른 객체를 명시적으로 반환하면 this가 아닌 return 문에 명시한 객체가 반환된다. (p240)

- **단, 명시적으로 원시 값을 반환하면 원시 값 반환은 무시되고 암묵적으로 this가 반환된다.** (p241)

- 하지만 생성자 함수 내부에서 this가 아닌 다른 값을 반환하는 것은 기본 동작을 훼손하기 때문에 return문을 반드시 생략하자. (p241)

<br>

> <i> 🏷️37장. Set과 Map </i>

### Map

- Map 객체는 키와 값의 쌍으로 이루어진 컬렉션으로 객체와 유사하지만 차이점이 존재한다. (p653)

| 구분                   | 객체                    | Map 객체              |
| ---------------------- | ----------------------- | --------------------- |
| 키로 사용할 수 있는 값 | 문자열 or 심벌 값       | 객체를 포함한 모든 값 |
| 이터러블               | X                       | O                     |
| 요소 개수 확인         | Object.keys(obj).length | map.size              |

- Map 객체는 Map 생성자 함수로 생성되며 **키와 값의 쌍으로 이루어진 이터러블**을 인수로 전달받아 생성된다. (p653)

- Map 생성자 함수의 인수로 전달한 이터러블에 중복된 키를 갖는 요소가 존재하면 값이 덮어씌워지므로 **Map 객체에는 중복된 키를 갖는 요소가 존재하지 않는다.** (p653)

- Map 객체에서는 NaN과 NaN을 같다고 평가하여 중복 추가를 허용하지 않는다. (p655)

- Map 객체는 요소의 순서에 의미를 갖지 않지만 Map 객체를 순회하는 순서는 요소가 추가된 순서를 따른다. 이는 다른 이터러블의 순회와 호환성을 유지하기 위함이다. (p659)

<br>

## 💡 새로 알게된 개념

> **렉시컬 환경(lexical environment)** <br>
> 특정 코드가 작성, 선언된 환경(장소)
> 즉, 코드의 문맥(context)는 렉시컬 환경으로 이뤄진다. <br><br>
> 스코프 체인은 실행 컨텍스트의 렉시컬 환경을 단방향으로 연결한 것이다. 전역 렉시컬 환경은 코드가 로드되면 곧바로 생성되고 함수의 렉시컬 환경은 함수가 호출되면 곧바로 생성된다.

> **실행 컨텍스트(execution context)** <br>
> 모든 코드는 실행 컨텍스트에서 평가되고 실행된다.

> **전역 객체(global object)** <br>
> 전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체다.
> 전역 객체는 클라이언트 사이드 환경(브라우저)에서는 window, 서버 사이드 환경(Node.js)에서는 global 객체를 의미한다.

> **this** <br>
> this는 객체 자신의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수다. <br> > **this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다.**

> **바인딩** <br>
> 식별자와 값을 연결하는 과정을 의미한다. 예를 들어, 변수 선언은 변수 이름과 확보된 메모리 공간의 주소를 바인딩 하는 것.
