## 🗝️ 오늘의 키워드

- 객체
- 함수

<br>

## ✏️ 밑줄친 부분

> <i> 🏷️10장. 객체 리터럴 </i>

- **원시 타입의 값, 즉 원시 값은 변경 불가능한 값(immutable value)이지만 객체 타입의 값, 즉 객체는 변경 가능한 값(mutable value)이다.** (p124)

- 객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키와 값으로 구성된다. (p124)

- 프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 **메서드(method)** 라 부른다. (p124)

- `프로퍼티`: 객체의 상태를 나타내는 값(data), `메서드`: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior) (p125)

- 인스턴스란 클래스에 의해 생성되어 메모리에 저장된 실체이다. 객체지향 프로그래밍에서 객체는 클래스와 인스턴스를 포함한 개념이다. (p125)

- 객체를 생성할 때 사용되는 중괄호(`{}`)는 객체 리터럴 이므로 코드 블록을 의미하지 않는다. 따라서 객체 리터럴 뒤에는 세미콜론(`;`)을 붙여야 한다. (p126)

- **프로퍼티 키는 일반적으로 문자열을 사용하기 때문에 따옴표로 묶어야 하지만, 식별자 네이밍 규칙을 준수하는 이름인 경우 따옴표를 생략할 수 있다.** (p127)

- 프로퍼티 키에 문자열이나 심벌 값 외의 값을 사용하면 암묵적 타입 변환을 통해 문자열이 된다. (p129)

- 이미 존재하는 프로퍼티 키를 중복 선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다. (p129)

<br>

> <i> 🏷️11장. 원시 값과 객체의 비교 </i>

- **원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다. 이에 비해 객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 참조 값이 저장된다.** (p137)

- 변수는 하나의 값을 저장하기 위해 확보된 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이고, 값은 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과를 말한다. **변경 불가능하다는 것은 변수가 아니라 값에 대한 진술이다.** (p138)

- 메모리를 효율적으로 사용하기 위해, 그리고 객체를 복사해 생성하는 비용을 절약하여 성능을 향상시키기 위해 객체는 변경 가능한 값으로 설계되어 있다. 하지만 부작용으로 원시 값과는 다르게 여러 개의 식별자가 하나의 객체를 공유할 수 있다. (p149)

- 객체 리터럴은 평가될 때마다 객체를 생성한다. 따라서 원본 객체와 사본 객체는 서로 다른 객체이다. 하지만 사본 객체는 원본 객체의 참조 값을 복사하여 가지고 있기 때문에 프로퍼티 값을 참조하는 `원본객체.name` 과 `사본객체.name` 등은 값으로 평가될 수 있는 표현식으로 서로 같다고 평가된다.

<br>

> <i> 🏷️12장. 함수 </i>

- 프로그래밍 언어의 함수는 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다. (p155)

- 함수를 호출하면 코드 블록에 담긴 문들이 일괄적으로 실행되고 실행결과, 즉 반환값을 반환한다. (p156)

- 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출된다. (p163)

- 자바스크립트의 함수는 값처럼 변수에 할당할 수도 있고 프로퍼티 값이 될 수도 있으며 배열의 요소가 될 수도 있다. 이처럼 값의 성질을 갖는 객체를 **일급 객체**라하며 함수는 일급 객체이다. (p163)

- 함수 선언문은 `표현식이 아닌 문` 이고, 함수 표현식은 `표현식인 문` 이다. (p164)

- 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 **함수 호이스팅**이라 한다. (p165)

- 함수 호이스팅과 변수 호이스팅에는 차이가 있다. var 키워드를 사용한 변수는 undefined로 초기화되고, 함수 선언문을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화된다. 따라서 var 키워드를 사용한 변수는 선언문 이전에 참조하면 undefined로 평가되지만, **함수 선언문**으로 정의한 함수는 함수 호이스팅에 의해 호출이 가능하다. 따라서 **함수 표현식으로 함수를 정의하면 함수 호이스팅이 아닌 변수 호이스팅이 발생한다.** (p165)

- 함수의 매개변수로 객체 타입 인수가 전달되면 참조 값이 복사되어 함수 몸체에서 참조 값을 통해 객체를 변경할 경우 외부의 원본이 훼손된다. 이를 해결하는 방법은 객체를 불변 객체로 만들어 사용하는 것이다. (p176)

- 외부의 원본에 영향을 끼치지 않고 객체의 상태 변경이 필요한 경우에는 깊은 복사를 통해 새로운 객체를 생성하고 재할당을 통해 교체해야 한다. 이렇게 외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수를 **순수 함수**라 한다. (p177)

- **함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수 라고 하며, 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수라고 한다. (p184)**

- 콜백 함수로서 전달된 함수 리터럴은 고차 함수가 호출될 때마다 평가되어 함수 객체를 생성한다. 따라서 콜백 함수를 익명 함수 리터럴로 정의하여 고차 함수에 전달하면 고차 함수가 호출될 때마다 콜백 함수가 생성된다. (p185)

<br>

> <i> 🏷️27장. 배열 </i>

<br>

## 💡 새로 알게된 개념

> **Object.is 메서드** <br>
> 동등 비교 연산자(==)와 일치 비교 연산자(===)는 NaN과 NaN, +0과 -0을 같지 않다고 평가하지만 ES6에서 도입된 `Object.is` 메서드는 예측 가능한 정확한 비교 결과를 반환한다.

<br>

- 대괄호 표기법에서 프로퍼티 키가 따옴표로 감싼 문자열이 아니라면 자바스크립트 엔진은 식별자로 인식한다. 따라서 아래의 `age` 는 식별자로 인식하여 선언된 `age` 를 찾지 못해 에러가 발생한다.

- 객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환한다. 이 때는 ReferneceError가 발생하지 않는다.

```javascript
const person = {
  age: 23,
};

console.log(person["age"]); // 23
console.log(person[age]); // ReferenceError: persone is not defined
console.log(person["name"]); // undefined
console.log(person[name]); // undefined
```
