## 🗝️ 오늘의 키워드

- 변수
- 데이터 타입
- 연산
- String

<br>

## ✏️ 밑줄친 부분

> <i> 🏷️04장. 변수 </i>

- 컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용해 데이터를 기억한다. 메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체로, 메모리 셀 하나의 크기는 1바이트(8비트)이고 컴퓨터는 메모리 셀의 크기인 1바이트 단위로 데이터를 저장하거나 읽어들인다. (p35)

- 값이 저장될 메모리 주소는 코드가 실행될 때 메모리 상황에 따라 임의로 결정되므로 동일한 코드를 실행하더라도 코드가 실행될 때마다 값이 저장될 메모리 주소가 변경된다. (p36)

- 따라서 메모리 주소를 통해 값에 직접 접근하는 방법은 올바르지 않기 때문에 프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위해 변수라는 매커니즘을 제공한다. (p36)

- **변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다. (= 값의 위치를 가리키는 상징적인 이름)** (p36)

- 변수 이름을 통해 변수에 저장된 값의 의미를 명확히 할 수 있기 때문에 잘 작성된 변수명은 가독성을 높이는 효과가 있다. (p38)

- `할당(assignment)`: 변수에 값을 저장하는 것 / `참조(reference)`: 변수에 저장된 값을 읽어 들이는 것

- `변수 선언 == 변수 생성`, 값을 저장하기 위해 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비한다. **변수를 사용하려면 반드시 선언이 필요하고 `var` `let` `const` 키워드를 사용한다.**(p39)

- **var 키워드를 사용하여 변수를 선언한 이후, 변수에 값을 할당하지 않아도 확보된 메모리 공간에는 자바스크립트 엔진에 의해 `undefined` 라는 값이 암묵적으로 할당되어 초기화된다.** (p41)

- 변수 선언 후 초기화 단계를 거치지 않으면 남아있는 이전 값인 쓰레기 값(garbage value)이 있을 수 있다. `var` 키워드는 암묵적으로 초기화를 수행하기 때문에 이러한 위험으로부터 안전하다. (p41)

- 변수 선언문보다 변수를 사용하는 것에 에러가 나지 않는 이유는 변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문이다. (p42)

- 자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기에 앞서 소스코드의 평가 과정을 거치면서 소스코드를 실행하기 위한 준비를 한다. 소스코드의 평가 과정에서 **변수 선언을 포함한 모든 선언문을 소스코드에서 찾아내 실행하고, 평가 과정이 끝나면 소스코드를 한 줄씩 순차적으로 실행한다.** (p42)

- 변수 선언문의 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 **변수 호이스팅**이라 한다. (p43)

- 변수에 값을 할당할 때는 변수 선언시 초기화된 `undefined`가 저장되어 있던 메모리 공간을 지우고 해당 공간에 할당 값을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그곳에 할당 값을 저장한다. (p45)

- **var 키워드로 선언한 변수는 값을 재할당할 수 있다. (p45)**

<br>

> <i> 🏷️06장. 데이터 타입 </i>

- 자바스크립트의 모든 값은 데이터 타입을 갖는다. (p59)

- 데이터 타입은 원시 타입과 객체 타입으로 나뉜다. (p59)

- ECMAScript 사양에 따르면 숫자 타입의 값은 배정밀도 64비트 부동소수점 형식을 따른다. 이는 정수로 표시된다 해도 사실은 실수라는 것을 의미한다. 따라서 **정수로 표시되는 수끼리 나누더라도 실수가 나올 수 있다.** (p60)

- Infinity, -Infinity, NaN 도 숫자형에 속한다. (p60)

- 다른 타입의 값과 달리 문자열을 따옴표로 감싸는 이유는 키워드나 식별자 같은 토큰과 구분하기 위해서이다. 문자열을 따옴표로 감싸지 않으면 자바스크립트 엔진은 키워드나 식별자 같은 토큰으로 인식한다. (p62)

- 템플릿 리터럴은 멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 편리한 문자열 처리 기능을 제공한다. 리터럴은 런타임에 일반 문자열로 변환되어 처리된다. (p62)

- `+` 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작하고, 그 외의 경우 덧셈 연산자로 동작한다. (p64)

- 표현식(`${}`)을 사용하면 표현식의 평가 결과가 문자열이 아니더라도 문자열로 타입이 강제로 변환되어 삽입된다. (p65)

- `undefined` 는 개발자가 의도적으로 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수를 초기화 할 때 사용하는 값이다. 따라서 변수를 참조했을 때 undefined가 반환된다면 참조한 변수가 선언 이후 값이 할당된 적이 없는, 초기화되지 않은 변수라는 것을 간파할 수 있다. 변수에 값이 없다는 것을 명시하고 싶을 때는 undefined가 아닌 null을 할당한다. (p66)

- 자바스크립트 엔진은 데이터 타입, 값의 종류에 따라 정해진 크기의 메모리 공간을 확보한다. (p69)

<br>

> <i> 🏷️ 07장. 연산 </i>

- 숫자 타입이 아닌 피연산자에 `+` 단항 연산자를 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다. **이때 피연산자를 변경하는 것이 아니라 숫자 타입으로 변환한 값을 생성해서 반환한다.** (p77)

- 할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다. 따라서 할당문을 다른 변수에 할당할 수도 있어서, 이러한 특징을 활용해 여러 변수에 동일한 값을 연쇄 할당할 수 있다. `a = b = c = 0;` (p80)

- 동등 비교(`==`) 연산자는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다. (p81)

- 드 모르간의 법칙은 논리 연산자로 구성된 가독성이 좋지 않은 복잡한 표현식을 가독성 좋은 표현식으로 변환할 수 있다. (p87)

- typeof 연산자로 null 값을 연산해 보면 “null”이 아닌 “object”를 반환한다. (p88)

<br>

> <i> 🏷️ 09장. 타입 변환과 단축 평가 </i>

- 값의 타입은 개발자의 의도에 따라 다른 타입으로 변환할 수 있다. 개발자가 의도적으로 값의 타입을 변환하는 것을 **명시적 타입 변환** or **타입 캐스팅**이라 한다. (p108)

- 개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다. 이를 **암묵적 타입 변환** 또는 **타입 강제 변환**이라 한다. (p108)

- 타입 변환이란 기존 원시 값을 사용해 다른 타입의 새로운 원시 값을 생성하는 것이다. (p109)

- 옵셔널 체이닝 연산자 `?.` 는 좌항의 피연산자가 null 또는 undefined인 경우 **undefined를 반환하고**, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다. (p122)

- 단축 평가인 논리 연산자 `&&` 는 Falsy값(false, undefined, null, 0, ‘ ‘. NaN)이면 좌항 피연산자를 반환하고, 옵셔널 체이닝 연산자 `?.` 은 null, undefined이면 undefined를 반환한다는차이가있다. (p122)

- null 병합 연산자(nullish coalescing)(`??`)는 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를, 그렇지 않으면 좌항의 피연산자를 반환한다. (p123)

<br>

> <i> 🏷️ 15장. let, const 키워드와 블록 레벨 스코프 </i>

- `var` 키워드로 선언한 변수의 문제점 (p208 - p210)

  - **중복 선언이 가능하다.** (= 에러가 발생하지 않는다. 이때, 초기화문이 없는 변수 선언문은 무시된다.)
  - **함수 레벨 스코프**: 함수 외부에서 var 키워드로 선언된 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다.
  - **변수 호이스팅**: 호이스팅은 프로그램의 흐름상 맞지 않고, 가독성을 떨어뜨리며 오류를 발생시킬 여지를 남긴다.

- `let` 키워드 (p210 - p214)

  - **변수 중복 선언 금지**
  - **블록 레벨 스코프**: 함수 외에 모든 코드 블록을 지역 스코프로 인정한다.
  - **변수 호이스팅이 발생하지 않는 것처럼 동작**: let 키워드로 선언한 변수는 **선언 단계**와 **초기화 단계**가 분리되어 진행된다. 즉, 선언 단계는 런타임 이전에 실행되지만 초기화 단계는 변수 선언문에 도달했을 때 실행된다. 따라서 초기화 단계 이전에 변수에 접근하려고 하면 참조 에러가 발생한다.
  - 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 **일시적 사각지대**(TDZ, Temporal Dead Zone)라고 부른다.

- `var` 키워드로 선언한 전역 변수와 전역 함수, 그리고 선언하지 않은 변수에 값을 할당한 암묵적 전역(`ex) y = 10`)은 전역 객체 `window`의 프로퍼티가 된다. 전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다. `let` 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다. (p214)

- `const` 키워드 (p215 - 217)
  - 상수를 선언하기 위해 사용한다.
  - **`const` 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.**
  - **블록 레벨 스코프**
  - **변수 호이스팅이 발생하지 않는 것처럼 동작**
  - **재할당 금지**
  - 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 변수라고 할 수 있지만, 변수처럼 재할당으로 변수 값을 변경할 수는 없다.
  - 일반적으로 상수의 이름은 대문자로 선언해 명확히 나타내고, 여러 단어로 이뤄진 경우에는 언더스코어(\_)로 구분해서 스네이크 케이스로 표현한다. `ex) TAX_RATE`

<br>

> <i> 🏷️ 32장. String </i>

- new 연산자를 사용하지 않고 String 생성자 함수를 호출하면 String 인스턴스가 아닌 문자열을 반환한다. 이를 이용해 명시적으로 타입을 변환하기도 한다. (p593)

- String 래퍼 객체는 유사 배열 객체이다. (p593)

- 문자열은 변경 불가능한 원시 값이기 때문에 String 래퍼 객체도 읽기 전용 객체로 제공된다. 따라서 **String 객체의 메서드는 언제나 새로운 문자열을 반환한다.** (p594)

<br>

## 💡 새로 알게된 개념

> **실행 컨텍스트(execution context)** <br>
> 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역. <br>
> 자바스크립트 엔진은 실행 컨텍스트를 통해 식별자와 스코프를 관리한다.

<br>

> **가비지 콜렉터(garbage collector)** > <br>
> 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제한다.
> 더 이상 사용되지 않는 메모리란, 어떤 식별자도 참조하지 않는 메모리 공간을 의미한다. 이를 통해 메모리 누수를 방지한다.
