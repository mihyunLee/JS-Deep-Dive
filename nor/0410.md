## 🗝️ 오늘의 키워드

- DOM
- Node
- HTMLCollection / NodeList
- textContent

<br>

## ✏️ 밑줄친 부분

> <i> 🏷️39장. DOM </i>

### 노드(Node)

- **DOM은 HTML 문서의 계층적 구조와 정보를 표현하며 이를 제어할 수 있는 API, 즉 프로퍼티와 메서드를 제공하는 트리 자료구조다.** (p677)

- HTML 요소는 HTML 문서를 구성하하는 개별적인 요소이며, 시작 태그 + 어튜리뷰터 이름 + 어트리뷰트 값 + 콘텐츠 + 종료 태그로 이루어져 있다. (p677)

- **HTML 요소는 렌더링 엔진에 의해 파싱되어 DOM을 구성하는 요소 노드 객체로 변환된다.** (p677)

- 어트리뷰트는 어트리뷰트 노드로, 텍스트 콘텐츠는 텍스트 노드로! (p677)

- HTML 요소 간에는 중첩 관계에 의해 계층적인 부자(부모-자식)관계가 형성된다. 이를 통해 HTML 요소를 객체화한 모든 노드 객체들을 트리 자료 구조로 구성한다. (p678)

- **트리 자료구조(tree data structure)는 노드들의 계층 구조로 이뤄지며 비선형 자료구조이다.** (p678)

- 트리 자료구조는 하나의 최상위 노드에서 시작한다. 최상위 노드는 부모 노드가 없으며, 루트 노드(root node)라 하고 루트 노드는 0개 이상의 자식 노드를 갖는다. (p678)

- 자식 노드가 없는 노드를 리프 노드(leaf node)라 한다. (p678)

- 노드 객체들로 구성된 트리 자료구조를 DOM이라 하고, DOM을 **DOM 트리**라고 부르기도 한다. (p679)

- 브라우저 환경의 모든 자바스크립트 코드는 script 태그에 의해 분리되어 있어도 **하나의 전역 객체 window**를 공유한다. 즉, HTML 문서당 document 객체는 유일하다. (p680)

- 요소 노드는 HTML 요소 간의 중첩에 의해 부자 관계를 통해 정보를 구조화하기 때문에 **문서의 구조를 표현한다**고 할 수 있다. (p680)

- 어트리뷰트 노드는 어트리뷰트가 지정된 HTML 요소의 요소 노드와 연결되어 있다. 단, **부모 노드와 연결되어 있지 않고 요소 노드에만 연결되어 있으므로 요소 노드의 형제 노드는 아니다.** 따라서 어트리뷰트 노드에 접근하여 참조하거나 변경하려면 먼저 요소 노드에 접근해야 한다. (p680)

- 텍스트 노드는 **문서의 정보를 표현한다**고 할 수 있다.
  또한, 텍스트 노도는 요소 노드의 자식 노드 이며, 자식 노드를 가질 수 없는 **리프 노드**이다. <br>
  즉, 텍스트 노드는 DOM 트리의 최종단이기 때문에 텍스트 노드에 접하려면 부모 노드인 요소 노드에 접근해야 한다. (p680)

- DOM API를 통해 노드 객체는 자신의 부모, 형제, 자식을 탐색할 수 있으며, 자신의 어트리뷰트와 텍스트를 조작할 수도 있다. (p681)

- 노드 객체의 상속 구조는 개발자 도구의 Elements 패널 우측의 Properties 패널에서 확인할 수 있다. (p683)

- 노드 객체는 공통된 기능일수록 프로토타입 체인의 상위에, 개별적인 고유 기능일수록 프로토타입 체인의 하위에 프로토타입 체인을 구축하여 **노드 객체에 필요한 기능, 즉 프로퍼티와 메서드를 제공하는 상속 구조를 갖는다.** (p684)

### 요소 노드 취득

- 요소 노드의 취득은 HTML 요소를 조작하는 시작점이다. 이를 위해 DOM은 요소 노드를 취득할 수 있는 다양한 메서드를 제공한다. (p685)

- `getElementById` 메서드는 Document.prototype의 프로퍼티다. 따라서 반드시 문서 노드인 `document` 를 통해 호출해야 한다.

```html
<!-- index.html -->
<div id="foo">
  <p id="text"></p>
</div>
```

```js
let foo = document.getElementById("foo");
foo.getElementById("text"); // TypeError: foo.getElementById is not a function
```

<br>

- HTML 요소에 id 어트리뷰트를 부여하면 id 값과 동일한 이름의 전역 변수가 암묵적으로 선언되고 해당 노드 객체가 할당되는 부수 효과가 있다. (p687)

```html
<!-- index.html -->
<div id="foo"></div>
```

```js
// index.js
console.log(foo === document.getElementById("foo")); // true

// 암묵적 전역으로 생성된 전역 프로퍼티는 삭제되지만 전역 변수는 삭제되지 않는다.
delete foo;
console.log(foo); // <div id="foo"></div>
```

- 단, id 값과 동일한 이름의 전역 변수가 이미 선언되어 있으면 이 전역 변수에 노드 객체가 재할당되지 않는다. ( ⇒ 암묵적으로 할당되지 않는다는 의미 ) (p687)

- HTML 문서의 모든 요소 노드를 취득하려면 `getElementByTagName()` 에 `"*"` 을 인수로 전달한다. 특정 요소 노드에서 호출하면, 자손 노드 중에서 모든 **요소 노드**를 탐색한다. (p689)

```html
<div id="foo">
  <!-- 주석입니다~ -->
  <p>hello</p>
  <p>hello</p>
</div>
```

```js
foo.getElementsByTagName("*"); // HTMLCollection(2) [p, p]
```

- querySelector, querySelectorAll 메서드는 getElement\*\* 메서드보다 다소 느리다고 알려져 있지만, CSS 선택자 문법을 사용하여 구체적인 조건과 일관된 방식으로 요소 노드를 취득할 수 있다는 장점이 있다. (p694)

- HTMLCollection은 언제나 live 객체로 동작하지만, NodeList는 경우에 따라 non-live 객체나 live 객체로 동작한다. (p695)

- childeNodes 프로퍼티가 반환하는 NodeList 객체는 실시간으로 노드 객체의 상태 변경을 반영하는 live 객체로 동작하므로 주의해야한다. (p698)

- **노드 객체의 상태 변경과 상관없이 안전하게 DOM 컬렉션을 사용하려면 HTMLCollection이나 NodeList 객체를 배열로 변환하여 사용하는 것을 권장한다. 각자 메서드가 제공되기는 하지만 배열의 고차 함수만큼 다양한 기능을 제공하지는 않는다.** (p699)

### 노드 탐색

- Node, Element 인터페이스는 트리 탐색 프로퍼티를 제공하는데 parentNode, previousSibling, firstChild, childNodes 프로퍼티는 Node.prototype이 제공하고, 프로퍼티 키에 Element가 포함된 previousElementSlibling, children 프로퍼티는 Element.prototype이 제공한다. (p701)

- **노트 탐색 프로퍼티는 모두 접근자 프로퍼티다.** 단, 노드 탐색 프로퍼티는 setter없이 getter만 존재하여 **참조만 가능한 읽기 전용 접근자 프로퍼티로 값을 할당하면 아무런 에러 없이 무시된다.** (p701)

### 노드 정보 취득

- 노드 객체에 대한 정보를 취득하려면 `Node.prototype.nodeType` `Node.prototype.nodeName` 과 같은 노드 정보 프로퍼티를 사용해야한다. (p709)
- Node.prototype.nodeType은 노드 타입에 따라 상수를 반환하고, nodeName은 노드 이름을 문자열로 반환한다. (p709)

### 요소 노드의 텍스트 조작

- 노드 객체의 `nodeValue` 프로퍼티를 참조하면 노드 객체의 값을 반환한다. 노드 객체의 값이란 텍스트 노드의 텍트이다. 따라서 텍스트 노드가 아닌 노드, 즉 문서 노드나 요소 노드의 `nodeValue` 프로퍼티를 참조하면 `null` 을 반환한다. (p710)

- 노드 객체의 `textNode` 프로퍼티를 참조하면 요소 노드의 콘텐츠 영역 내의 텍스트(개행 포함, 주석 포함X)를 모두 반환한다. 이때 HTML 마크업은 무시하고 반환된다. (p712)

- 요소 노드의 textContent 프로퍼티에 문자열을 할당할 때 할당한 문자열에 HTML 마크업이 포함되어 있더라도 HTML 마크업이 파싱되지 않고 그대로 인식되어 취급된다. (p713)

- `innerText` 의 경우 CSS에 의해 비표시로 지정된 요소 노드의 텍스트를 반환하지 않고, CSS를 고려해야하여 속도가 비교적 느리기 때문에 사용을 권장하지 않는다. (p714)

### 클래스 조작

- `className` 프로퍼티는 문자열을 반환하므로 공백으로 구분된 여러 개의 클래스를 반환하는 경우 다루기가 불편하다. (p748)

- `classList` 프로퍼티는 class 어트리뷰트의 정보를 담은 DOMTokenList 객체를 반환한다. (p748)

- DOMTokenList 객체는 forEach, entries, keys, values, supports 메서드를 제공한다. (p750)

- `style` 프로퍼티는 인라인 스타일만 반환한다. HTML 요소에 적용되어 있는 모든 CSS 스타일을 참조해야 할 경우 `getComputedStyle` 메서드를 사용한다. (p751)

- 평가된 스타일이란 요소 노드에 적용되어있는 모든 스타일, 즉 링크, 임베딩, 인라인, 자바스크립트 에서 적용한 스타일, 상속, 기본(user agent) 스타일 등 모든 스타일이 조합되어 최종적으로 적용된 스타일을 말한다. (p751)

<br>

> <i> 🏷️40장. 이벤트 </i>

### 이벤트 드리븐 프로그래밍

- 이벤트가 발생했을 때 호출될 함수를 **이벤트 핸들러**라 하고, 이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것을 **이벤트 핸들러 등록**이라 한다. (p754)

- 이벤트와 그에 대응하는 함수(이벤트 핸들러)를 통해 사용자와 애플리케이션은 상호작용을 할 수 있다. 이와 같이 프로그램의 흐름을 이벤트 중심으로 제어하는 프로그래밍 방식을 **이벤트 드리븐 프로그래밍**이라 한다. (p755)

### 이벤트 타입

- `focusin` `focusout` 이벤트 핸들러를 프로퍼티 방식으로 등록하면 크롬, 사파리에서 정상 동작하지 않기 때문에 `addEventListener` 메서드 방식을 사용해 등록해야 한다. (p756)

### 이벤트 핸들러 등록

- HTML 요소의 어트리뷰트 중 이벤트 핸들러 어트리뷰트 값으로 **함수 호출문 등의 문(함수 참조가 아님)**을 할당하여 이벤트 핸들러를 등록할 수 있다. (p758)

- 이벤트 핸들러 어트리뷰트 값은 파싱되어 어트리뷰트와 동일한 이름의 함수를 암묵적으로 생성하고, 이벤트 핸들러 어트리뷰트 이름과 동일한 키의 이벤트 핸들러 프로퍼티에 할당한다. 만약 이벤트 핸들러 어트리뷰트 값으로 함수 참조를 할당해야 한다면 이벤트 핸들러에 인수를 전달하기 곤란하기 때문에 호출문과 같은 문을 할당해야 한다. (p758)

- CBD(Component Based Development) 방식의 Angular/React/Svelte/Vue.js와 같은 프레임워크/라이브러리에서는 이벤트 핸들러 어트리뷰트 방식으로 이벤트를 처리한다. <br>
  HTML, CSS, JavaScript를 관심사가 다른 개별적인 요소가 아닌, 뷰를 구성하기 위한 구성 요소로 보기 때문에 관심사가 다르다고 생각하지 않는다. (p760)

<br>

## 💡 새로 알게된 개념

> **비선형 자료구조** <br>
> 하나의 자료 뒤에 여러 개의 자료가 존재할 수 있는 자료구조 <br>
> ex) 트리, 그래프

> **HTMLCollection에서의 forEach()** <br>
> NodeList의 경우 forEach() 메서드를 사용할 수 있지만(그렇다고 배열의 forEach()는 아니다), HTMLCollection은 사용할 수 없다. <br>
> 따라서 **전개구문을 사용하여 배열로 변환**해준 후, forEach()를 사용하는 방법을 고려해볼 수 있다.
