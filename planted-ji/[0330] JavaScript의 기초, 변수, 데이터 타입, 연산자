### 오늘의 키워드

- JavaScript의 탄생
- 변수
- 숫자 타입, undefined 타입
- 산술 연산자, 비교 연산자

### 밑줄 친 부분

### 02 : 자바스크립트란?

<aside>
💡 1995년, 웹 브라우저 시장의 약 90%를 점유하던 넷스케이프가 웹페이지의 보조 기능을 수행하기 위해 브렌던 아이크의 주도 하에 개발한 언어. *(p. 7)*

</aside>

<aside>
💡 1999년, Ajax의 등장으로 페이지 전체를 렌더링하던 기존의 불리한 방식에서 수정된 부분만 렌더링하는 방식으로 빠른 성능과 부드러운 화면 전환을 제공하게 되었다. *(p. 9)*

</aside>

<aside>
💡 자바스크립트는 프로그래밍 언어로서 기본 뼈대를 이루는 ECMAScript와 브라우저가 별도 지원하는 클라이언트 사이드 Web API(DOM, BOM, Canvas 등등)을 아우르는 개념. *(p. 13)*

</aside>

<aside>
💡 대부분의 모던 자바스크립트 엔진(크롬의 V8, 파이어폭스의 SpiderMonkey 등)은 인터프리터와 컴파일러의 장점을 결합해 비교적 처리 속도가 느린 인터프리터의 단점을 해결한다. *(p. 14)*

</aside>

 

### 03 : 자바스크립트 개발 환경과 실행 방법

<aside>
💡 모든 브라우저는 자바스크립트를 해석하고 실행할 수 있는 자바스크립트 엔진을 내장한다. (p.17)

</aside>

### 04 : 변수

<aside>
💡 변수는 값의 위치를 가리키는 상징적인 이름이다. 메모리 공간에 저장된 값을 다시 읽어 들여 재사용할 수 있도록 값이 저장된 메모리 공간에 상징적인 이름을 붙인 것이 바로 변수다. *(p. 37)*

</aside>

<aside>
💡 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름을 변수명, 변수에 저장된 값을 변수 값, 변수에 값을 저장하는 것을 할당, 변수에 저장된 값을 읽어 들이는 것을 참조라 한다. *(p. 38)*

</aside>

<aside>
💡 메모리 공간에 저장된 값을 구별하기 위해, 식별자는 값이 저장되어 있는 메모리 주소를 기억해야 한다. 식별자는 값이 아니라 메모리 주소를 기억하고 있다. *(p. 39)*

</aside>

<aside>
💡 변수 선언에 의해 확보된 메모리 공간은 비어 있을 것으로 생각할 수 있으나 undefined라는 값이 암묵적으로 할당되어 초기화된다. *(p. 41)*

</aside>

<aside>
💡 변수에 값을 할당할 때는 이전 값 undefined가 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 할당 값 80을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그곳에 할당 값 80을 저장한다. *(p. 45)*

</aside>

### 06 : 데이터 타입

<aside>
💡 모든 수를 실수로 처리하며, 정수만 표현하기 위한 데이터 타입이 별도로 존재하지 않는다. *(p. 60)*

</aside>

<aside>
💡 이는 정수로 표시된다 해도 사실은 실수라는 것을 의미한다. 따라서 정수로 표시되는 수끼리 나누더라도 실수가 나올 수 있다. *(p. 60)*

</aside>

<aside>
💡 undefined는 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값이다. 개발자가 의도적으로 변수에 할당한다면 본래 취지와 어긋날뿐더러 혼란을 줄 수 있으므로 변수에 값이 없다는 것을 명시하고 싶을 때는 null을 할당한다. *(p. 66)*

</aside>

### 07 : 연산자

<aside>
💡 숫자 타입이 아닌 피연산자에 + - 단항 연산자를 사용하면 피연산자를 숫자타입으로 변환하여 반환한다. *(p. 77)*

</aside>

<aside>
💡 + 연산자는 피연산자 중 하나 이상인 문자열인 경우 문자열 연결 연산자로 동작한다. 개발자의 의도와 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되는 것을 암묵적 타입 변환(implicit coercion) 또는 타입 강제 변환(type coercion)이라고 한다. *(p. 78)*

</aside>

### 이해 가지 않는 부분

<aside>
❓

</aside>

### 새롭게 알게 된 부분

<aside>
✨ **Number.isNaN(1 + undefined); 의 값이 true인 이유**

JavaScript에서 undefined를 다른 값과 더하면 결과는 NaN이 됩니다.

따라서 1 + undefined는 NaN을 반환하고, 입력된 값이 NaN(Not a Number)인지 여부를 검사하는 Number.isNaN() 메소드에 의해 Number.isNaN(1 + undefined)는 true를 반환합니다.

</aside>
