# switch 문, 반복문, 스프렌드 문법, 디스트럭처링 할당

## 오늘의 키워드

- switch 문
- for … in 문
- for … of 문
- break 문
- continue 문
- label 문
- 스프레드 문법
- 디스트럭처링 할당

## 밑줄 친 부분

08장 제어문

> 💡 if … else 문은 논리적 참, 거짓으로 실행할 코드 블록을 결정한다 switch문은 논리적 참, 거짓보다는 다양한 상황(case)에 따라 실행할 코드 블록을 결정할 때 사용한다. p.97

> 💡 switch 문의 표현식의 평가 결과와 일치하는 case 문으로 실행 흐름이 이동하여 실행한 후 switch 문을 탈출하지 않고 switch 문이 끝날 때까지 이후의 모든 case문과 default 문을 실행하는 것을 폴스루라 한다. p.98

> 💡 폴스루를 활용해 여러 개의 case 문을 하나의 조건으로 사용할 수도 있다. p.99

> 💡 for 문의 변수 선언문, 조건식, 증감식은 모두 옵션이므로 반드시 사용할 필요는 없다. 단, 어떤 식도 선언하지 않으면 무한루프가 된다. p.53

> 💡 for 문은 반복 횟수가 명확할 때 주로 사용하고 while 문은 반복 횟수가 불명확할 때 주로 사용한다. p.103

19장 프로토타입

> 💡 for … in 문은 객체의 프로퍼티 개수만큼 순회하며 for … in 문의 변수 선언문에서 선언한 변수에 프로퍼티 키를 할당한다. … in 연산자처럼 순회 대상 객체의 프로퍼티뿐만 아니라 상속받은 프로토타입의 프로퍼티까지 열거한다. p. 308

> 💡 for … in 문은 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중에서 프로퍼티 어트리뷰트 [[Enumerable]](프로퍼티의 열거 가능 여부)의 값이 true인 프로퍼티를 순회하며 열거한다. p. 309

> 💡 상속받은 프로퍼티는 제외하고 객체 자신의 프로퍼티만 열거하려면 Object.prototype.hasOwnProperty 메서드를 사용하여 객체 자신의 프로퍼티인지 확인해야 한다. p. 309

> 💡 for … in 문은 프로퍼티를 열거할 때 순서를 보장하지 않으므로 주의하기 바란다. 하지만 대부분의 모던 브라우저는 순서를 보장하고 숫자(사실은 문자열)인 프로퍼티 키에 대해서는 정렬을 실시한다. p. 310

> 💡 배열에는 for … in 문을 사용하지 말고 일반적인 for 문이나 for … of 문 또는 Array.prototype.forEach 메서드를 사용하기를 권장한다. 사실 배열도 객체이므로 프로퍼티와 상속받은 프로퍼티가 포함될 수 있다. p. 311

```javascript
const arr = [1, 2, 3];
arr.x = 10;

for (const i in arr) {
  console.log(arr[i]); // 1 2 3 10
}

for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]); // 1 2 3
}

arr.forEach((v) => console.log(v)); // 1 2 3

for (const value in arr) {
  console.log(value); // 1 2 3
}
```

34장 이터러블

> 💡 이터레이션 프로토콜은 순회 가능한 데이터 컬렉션(자료구조)을 만들기 위해 ECMAScript 사양에 정의하여 미리 약속한 규칙이다. … 이터레이션 프로토콜에는 이터러블 프로토콜과 이터레이터 프로토콜이 있다. p. 614

> 💡 이터러블은 Symbol.iterator를 프로퍼티 키로 사용한 메서드를 직접 구현하거나 프로토타입 체인을 통해 상속받은 객체를 말한다. … 이터러블은 for … of 문으로 순회할 수 있으며, 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 있다. p. 615

> 💡 이터러블의 Symbol.iterator 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환한다. 이터러블의 Symbol.iterator가 반환한 이터레이터는 next 메서드를 갖는다. p. 616

> 💡 이터레이터의 next 메서드는 이터러블의 각 요소를 순회하기 위한 포인터의 역할을 한다. 즉, next 메서드를 호출하면 이터러블을 순차적으로 한 단계씩 순회하며 순회 결과를 나타내는 이터레이터 리절트 객체를 반환한다. 이터레이터 리절트 객체의 value 프로퍼티는 현재 순회 중인 이터러블의 값을 나타내며 done 프로퍼티는 이터러블의 순회 완료 여부를 나타낸다. p. 617

> 💡 for … of 문은 내부적으로 이터레이터의 next 메서드를 호출하여 이터러블을 순회하며 next 메서드가 반환한 이터레이터 리절트 객체의 value 객체의 value 프로퍼티 값을 for … of 문의 변수에 할당한다. 그리고 이터레이터 리절트 객체의 done 프로퍼티 값이 false이면 이터러블의 순회를 계속하고 true이면 이터러블의 순회를 중단한다. p. 618

35장 스프레드 문법

> 💡 스프레드 문법 …은 하나로 뭉쳐 있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록으로 만든다. p. 627

> 💡 스프레드 문법을 사용할 수 있는 대상은 Array, String, Map, Set, DOM 컬렉션(NodeList, HTMLCollection), arguments와 같이 for … of 문으로 순회할 수 있는 이터러블에 한정된다. p. 627

> 💡 스프레드 문법의 결과는 값이 아니다. 스프레드 문법 …은 피연산자를 연산하여 값을 생성하는 연산자가 아니다. 따라서 스프레드 문법의 결과는 변수에 할당할 수 없다. p. 627

> 💡 스프레드 프로퍼티를 사용하면 객체 리터럴의 프로퍼티 목록에서도 스프레드 문법을 사용할 수 있다. 스프레드 문법의 대상은 이터러블이어야 하지만 스프레드 프로퍼티 제안은 일반 객체를 대상으로도 스프레드 문법의 사용을 허용한다. p. 634

36장 디스트럭처링 할당

> 💡 디스트럭처링 할당은 구조화된 배열과 같은 이터러블 또는 객체를 destructuring하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다. 이터러블 또는 객체 리터럴에서 필요한 값만 추출하여 변수에 할당할 때 유용하다. p. 636

> 💡 배열 디스트럭처링 할당을 위해서는 할당 연산자 왼쪽에 값을 할당받을 변수를 선언해야 한다. 이때 변수를 배열 리터럴 형태로 선언한다. 이때 우변에 이터러블을 할당하지 않으면 에러가 발생한다. p. 637

> 💡 배열 디스트럭처링 할당의 기준은 배열의 인덱스다. 즉, 순서대로 할당된다. 이때 변수의 개수와 이터러블의 개수가 반드시 일치할 필요는 없다. p. 637

> 💡 객체 디스트럭처링 할당을 위해서는 할당 연산자 왼쪽에 프로퍼티 값을 할당받을 변수를 선언해야 한다. 이때 변수를 객체 리터럴 형태로 선언한다. 이때 우변에 객체 또는 객체로 평가될 수 있는 표현식(문자열, 숫자, 배열 등)을 할당하지 않으면 에러가 발생한다. p. 640

> 💡 객체 디스트럭처링 할당의 할당 기준은 프로퍼티 키다. 즉, 순서는 의미가 없으며 선언된 변수 이름과 프로퍼티가 일치하면 할당된다. p. 639

> 💡 객체의 프로퍼티 키와 다른 변수 이름으로 프로퍼티 값을 할당받으려면 변수의 프로퍼티 값을 다르게 변수를 선언한다. p. 639

> 💡 객체 디스트럭처링 할당은 객체를 인수로 전달하는 함수의 매개변수에도 사용할 수 있다. p. 640

> 💡 배열/객체 디스트럭처링 할당을 위한 변수에 기본값을 설정할 수 있다. p. 638, 640

> 💡 배열/객체 디스트럭처링 할당을 위한 변수에 Rest 파라미터와 유사하게 Rest 요소 …을 사용할 수 있다. Rest 요소는 Rest 파라미터와 마찬가지로 반드시 마지막에 위치해야 한다. p. 639, 642
